<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <title>TouchMeJoystick with Orbital Controls support</title>
    <style>
        html { overflow-y: scroll; }
        body { margin: 20px; }
        #output {
            font-family: monospace;
            font-size: 11px;
            background: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
            margin: 10px 0;
        }
        #output td { padding: 2px 8px; }
        #output .active { background: #90EE90; }
        #output .pressed { background: #FFB6C1; }
        canvas { 
            border: 1px solid black; 
            touch-action: none;
            display: block;
            margin: 10px 0;
        }
        #info {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            position: absolute;
            top: 10px;
            right: 10px;
            font-family: Arial;
            font-size: 12px;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.179.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.179.1/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <h2>TouchMeJoystick with Orbital Controls support</h2>
    <p>Note: virtual buttons and joystick only work on Touch devices (Mobile phones, Tablets, etc), <strong>not</strong> on mouse clicks.</p>
    <p>You can connect your physical joystick and it should also work.</p>
    <pre id="output">Loading...</pre>
    <div id="threejs-container" style="position: relative;"></div>

    <script type="module">
        import { InputManager, StandardMapping } from './src/input/core/InputManager.js';
        import { ThreeJSRenderer } from './src/input/renderers/ThreeJSRenderer3DPerspective.js';
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        const output = document.getElementById('output');
        const container = document.getElementById('threejs-container');

        function getWebGLErrorMessage() {
            const message = document.createElement('div');
            message.style.cssText = `
                font-family: Arial, sans-serif;
                font-size: 13px;
                font-weight: normal;
                text-align: center;
                background: #fff;
                color: #000;
                padding: 1.5em;
                width: 400px;
                margin: 5em auto;
                border: 1px solid #ccc;
                border-radius: 4px;
            `;

            if (!window.WebGLRenderingContext) {
                message.innerHTML = `
                    <h2>WebGL Not Supported</h2>
                    <p>Your browser does not support WebGL.</p>
                    <p>(If using Mac/iOS, check if Lockdown Mode is enabled for this site.)</p>
                    <p>Find out how to get it at 
                    <a href="https://get.webgl.org/" style="color: #000">get.webgl.org</a></p>
                `;
            } else {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    message.innerHTML = `
                        <h2>WebGL Not Enabled</h2>
                        <p>Your browser supports WebGL but it is disabled or unavailable.</p>
                        <p>(If using Mac/iOS, check if Lockdown Mode is enabled for this site.)</p>
                        <p>Find out how to enable it at 
                        <a href="https://get.webgl.org/troubleshooting/" style="color: #000">
                        get.webgl.org/troubleshooting</a></p>
                    `;
                }
            }
            
            return message;
        }

        if (!window.WebGLRenderingContext || 
            !(document.createElement('canvas').getContext('webgl') || 
            document.createElement('canvas').getContext('experimental-webgl'))) {
            document.body.appendChild(getWebGLErrorMessage());
            throw new Error('WebGL not available');
        }
        
        // Setup Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        scene.fog = new THREE.Fog(0xf0f0f0, 100, 1000);
        
        // Perspective camera
        const camera = new THREE.PerspectiveCamera(
            60,
            (window.innerWidth - 40) / 400,
            0.1,
            1000
        );
        camera.position.set(200, 300, 200);

        // Create UI scene with orthographic camera for the joystick
        const uiScene = new THREE.Scene();
        const uiCamera = new THREE.OrthographicCamera(
            -window.innerWidth/2, window.innerWidth/2,
            window.innerHeight/2, -window.innerHeight/2,
            0.1, 1000
        );
        //uiCamera.position.z = 100;
        uiCamera.position.set(0, -100, 100); // Move camera back and up
        uiCamera.lookAt(0, 0, 0); // Look at center

        // Add lights to UI scene
        const uiAmbientLight = new THREE.AmbientLight(0xffffff, 0.8);
        uiScene.add(uiAmbientLight);

        const uiDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        uiDirectionalLight.position.set(0, 50, 100);
        uiScene.add(uiDirectionalLight);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - 40, 400);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.autoClear = false;
        container.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.4);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -200;
        directionalLight.shadow.camera.right = 200;
        directionalLight.shadow.camera.top = 200;
        directionalLight.shadow.camera.bottom = -200;
        scene.add(directionalLight);
        
        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(500, 500);
        const groundMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x808080,
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = Math.PI / 2;
        ground.position.y = -30;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Add a platform for the controls
        const platformGeometry = new THREE.CylinderGeometry(150, 180, 10, 32);
        const platformMaterial = new THREE.MeshPhongMaterial({ color: 0xff4444 });
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.y = -25;
        platform.castShadow = true;
        platform.receiveShadow = true;
        scene.add(platform);
        
        // Orbital controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.enablePan = false;
        controls.minDistance = 200;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI * 0.85;
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        let orbitControlsEnabled = true;

        // Create UI controls with the UI scene
        const uiRenderer = new ThreeJSRenderer(uiScene, uiCamera, renderer);
        
        // Create input system
        const inputManager = new InputManager();
        //const threejsRenderer = new ThreeJSRenderer(scene, camera, renderer);
        //threejsRenderer.controls = controls; // Pass controls reference
        
        const thumbRadius = 20;
        const touchInput = inputManager.createOnScreenDevice({ 
            renderer: uiRenderer, 
            thumbRadius: thumbRadius
        });
        
        // Create joystick on the left
        const width = window.innerWidth - 40;
        const height = 400;

        const joystick = touchInput.createJoystick({
            position: { x: -width * 0.3, y: -height/2 + 80 },
            size: 60,
            id: 'joystick'
        });

        const buttonsCenterX = width * 0.25;
        const buttonsCenterY = -height/2 + 80;
        
        // Create buttons in a diamond pattern on the right
        const buttonRadius = 60;
        const buttonA = touchInput.createButton({
            position: { x: buttonsCenterX, y: buttonsCenterY - 2.2 * thumbRadius },
            size: thumbRadius * 1.2,
            buttonIndex: 0,
            label: 'A',
            labelColor: '#ffffff',
            color: 0xff0000,
            id: 'buttonA'
        });
        
        const buttonB = touchInput.createButton({
            position: { x: buttonsCenterX + 2.2 * thumbRadius, y: buttonsCenterY },
            size: thumbRadius * 1.2,
            buttonIndex: 1,
            label: 'B',
            color: 0x00ff00,
            labelColor: '#ffffff',
            id: 'buttonB'
        });
        
        const buttonX = touchInput.createButton({
            position: { x: buttonsCenterX - 2.2 * thumbRadius, y: buttonsCenterY },
            size: thumbRadius * 1.2,
            buttonIndex: 2,
            label: 'X',
            color: 0x0000ff,
            labelColor: '#ffffff',
            id: 'buttonX'
        });
        
        const buttonY = touchInput.createButton({
            position: { x: buttonsCenterX, y: buttonsCenterY + 2.2 * thumbRadius },
            size: thumbRadius * 1.2,
            buttonIndex: 3,
            label: 'Y',
            color: 0xffff00,
            labelColor: '#000000',
            id: 'buttonY'
        });
        
        // Add visual indicators for button presses
        const createButtonGlow = (position, color) => {
            const glowGeometry = new THREE.RingGeometry(thumbRadius * 1.5, thumbRadius * 2, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(position);
            glow.position.z -= 5;
            glow.rotation.x = Math.PI / 2;
            scene.add(glow);
            return glow;
        };
        
        const glows = {
            A: createButtonGlow(buttonA.position, 0xff0000),
            B: createButtonGlow(buttonB.position, 0x00ff00),
            X: createButtonGlow(buttonX.position, 0x0000ff),
            Y: createButtonGlow(buttonY.position, 0xffff00)
        };
        
        // Override touch handling to manage orbital controls
        const originalTouchStart = touchInput._handleTouchStart.bind(touchInput);
        touchInput._handleTouchStart = function(event) {
            // Check if any control will be touched BEFORE calling original
            let touchedControl = false;
            for (const touch of event.changedTouches) {
                const screenX = touch.clientX;
                const screenY = touch.clientY;
                
                for (const control of this.controls.values()) {
                    if (control.containsPoint(screenX, screenY, this.thumbRadius, this.thumbRadius)) {
                        touchedControl = true;
                        break;
                    }
                }
            }
            
            // Disable orbit controls if touching a control
            if (touchedControl) {
                controls.enabled = false;
                orbitControlsEnabled = false;
            }
            
            // Now call the original handler
            return originalTouchStart(event);
        };
        
        const originalTouchEnd = touchInput._handleTouchEnd.bind(touchInput);
        touchInput._handleTouchEnd = function(event) {
            const result = originalTouchEnd(event);
    
            // Re-enable orbit controls if no active touches on any controls
            if (this.activeTouches.size === 0) {
                controls.enabled = true;
                orbitControlsEnabled = true;
            }
            return result;

        };

        // Also prevent orbit controls on touch move if a control is active
        const originalTouchMove = touchInput._handleTouchMove.bind(touchInput);
        touchInput._handleTouchMove = function(event) {
            if (this.activeTouches.size > 0) {
                controls.enabled = false;
            }
            return originalTouchMove(event);
        };
        
        // Handle resize
        const resize = () => {
            const width = window.innerWidth - 40;
            const height = 400;
            
            renderer.setSize(width, height);

            // Update perspective camera
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            // Update orthographic camera
            const aspect = width / height;
            const frustumHeight = height;
            const frustumWidth = frustumHeight * aspect;

            uiCamera.left = -frustumWidth/2;
            uiCamera.right = frustumWidth/2;
            uiCamera.top = frustumHeight/2;
            uiCamera.bottom = -frustumHeight/2;
            uiCamera.updateProjectionMatrix();

            // Re-position camera to maintain the tilt
            uiCamera.position.set(0, -100, 100);
            uiCamera.lookAt(0, 0, 0);

            // Update control positions based on new dimensions
            joystick.position = { x: -frustumWidth * 0.3, y: -frustumHeight/2 + 80 };
            
            const buttonsCenterX = frustumWidth * 0.25;
            buttonA.position = { x: buttonsCenterX, y: buttonsCenterY - 2.2 * thumbRadius };
            buttonB.position = { x: buttonsCenterX + 2.2 * thumbRadius, y: buttonsCenterY };
            buttonX.position = { x: buttonsCenterX - 2.2 * thumbRadius, y: buttonsCenterY };
            buttonY.position = { x: buttonsCenterX, y: buttonsCenterY + 2.2 * thumbRadius };
            
        };

        // check if any touch control is active (to allow disabling of OrbitControls)
        function isAnyControlActive() {
            // Check if any control is being touched (not just pressed)
            for (const control of touchInput.controls.values()) {
                if (control.touchId !== null) {  // Control is being touched
                    return true;
                }
            }
            return false;
        }


        // Add a character to control with joystick

        const characterGeometry = new THREE.CapsuleGeometry(10, 30, 8, 16);
        const characterMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x00ff00,
            shininess: 100 
        });
        const character = new THREE.Mesh(characterGeometry, characterMaterial);
        character.position.set(0, 15, 0); // Start at center, slightly above ground
        character.castShadow = true;
        character.receiveShadow = true;;
        scene.add(character);

        // Add a "face" to show direction
        const faceGeometry = new THREE.ConeGeometry(5, 10, 8);
        const faceMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff });
        const face = new THREE.Mesh(faceGeometry, faceMaterial);
        face.rotation.z = -Math.PI / 2;
        face.position.x = 15;
        scene.add(face);
        character.add(face);

        // Add eyes after creating the face
        const eyeGeometry = new THREE.SphereGeometry(5, 16, 16);
        const leftEyeMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
        const rightEyeMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
        const pupilGeometry = new THREE.SphereGeometry(4, 16, 16);
        const pupilMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });

        // Left eye
        const leftEye = new THREE.Mesh(eyeGeometry, leftEyeMaterial);
        leftEye.position.set(10, 8, 8);
        character.add(leftEye);

        const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        leftPupil.position.x = 1;
        leftEye.add(leftPupil);

        // Right eye
        const rightEye = new THREE.Mesh(eyeGeometry, rightEyeMaterial);
        rightEye.position.set(10, 8, -8);
        character.add(rightEye);

        const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        rightPupil.position.x = 1;
        rightEye.add(rightPupil);

        // Create sad smile using partial torus
        const smileGeometry = new THREE.TorusGeometry(6, 0.8, 8, 20, Math.PI);
        const smileMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
        const smile = new THREE.Mesh(smileGeometry, smileMaterial);
        smile.position.set(10, -10, 0); // Same X as eyes
        //smile.rotation.z = Math.PI; // Flip to make it sad
        smile.rotation.y = Math.PI / 2; // Face forward
        character.add(smile);


        // Fireball system
        const fireballs = [];
        const fireballSpeed = 200;
        const fireballGeometry = new THREE.SphereGeometry(3, 16, 16);
        const fireballMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff4400,
            emissive: 0xff2200,
            emissiveIntensity: 0.5
        });

        // Character movement properties
        const characterSpeed = 100; // units per second
        const characterRotationSpeed = 3; // radians per second
        let characterVelocity = new THREE.Vector3();
        let characterRotation = 0;
        
        function handleJoystickInputs(deltaTime) {
            // Character movement based on joystick
            const stick = inputManager.getStick('LEFT');
            const joystickX = stick.x;
            const joystickY = stick.y;
            
            // Rotation based on X axis
            if (Math.abs(joystickX) > 0.1) {
                characterRotation -= joystickX * characterRotationSpeed * deltaTime;
                character.rotation.y = characterRotation;
            }
            
            // Movement based on Y axis (forward/backward in character's direction)
            if (Math.abs(joystickY) > 0.1) {
                const speed = -joystickY * characterSpeed;
                const moveAngle = characterRotation - Math.PI / 2;
                characterVelocity.x = Math.sin(moveAngle) * speed;
                characterVelocity.z = Math.cos(moveAngle) * speed;
            } else {
                // Stop movement
                characterVelocity.x *= 0.9; // Friction
                characterVelocity.z *= 0.9;
            }
            
            // Update position
            character.position.x += characterVelocity.x * deltaTime;
            character.position.z += characterVelocity.z * deltaTime;
            
            // Button actions from the loop
            if (inputManager.isButtonPressed('A')) {
                // Jump
                if (character.position.y <= 15) {
                    characterVelocity.y = 200;
                }
            }
            
            // Apply gravity
            characterVelocity.y -= 500 * deltaTime;
            character.position.y += characterVelocity.y * deltaTime;
            
            // Ground collision
            if (character.position.y < 15) {
                character.position.y = 15;
                characterVelocity.y = 0;
            }

        }

        function fireballUpdates(deltaTime) {
            // Update fireballs
            for (let i = fireballs.length - 1; i >= 0; i--) {
                const fireball = fireballs[i];
                
                // Move fireball
                fireball.position.x += fireball.userData.velocity.x * deltaTime;
                fireball.position.z += fireball.userData.velocity.z * deltaTime;
                
                // Update lifetime
                fireball.userData.lifetime -= deltaTime;
                
                // Remove if expired or too far
                if (fireball.userData.lifetime <= 0 || fireball.position.length() > 500) {
                    scene.remove(fireball);
                    fireballs.splice(i, 1);
                }
            }
        }

        inputManager.on('buttondown', (event) => {
            if (event.button === StandardMapping.buttons.Y) {
                leftEye.material.color.setHex(0x000000);
            }
            if (event.button === StandardMapping.buttons.B) {
                rightEye.material.color.setHex(0x000000);
            }
            if (event.button === StandardMapping.buttons.X) {
                // Create fireball
                const fireball = new THREE.Mesh(fireballGeometry, fireballMaterial);
                fireball.position.copy(character.position);
                fireball.position.y += 10; // Slightly above character
                
                // Set fireball direction based on character rotation
                fireball.userData.velocity = new THREE.Vector3(
                    Math.sin(characterRotation + Math.PI / 2) * fireballSpeed,
                    0,
                    Math.cos(characterRotation + Math.PI / 2) * fireballSpeed
                );
                
                fireball.userData.lifetime = 3; // 3 seconds
                scene.add(fireball);
                fireballs.push(fireball);
            }
        });

        inputManager.on('buttonup', (event) => {
            if (event.button === StandardMapping.buttons.Y) {
                leftEye.material.color.setHex(0xffffff);
            }
            if (event.button === StandardMapping.buttons.B) {
                rightEye.material.color.setHex(0xffffff);
            }
        });

        let lastTime = performance.now();
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Calculate deltaTime
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
            lastTime = currentTime;
            
            controls.update();
            inputManager.update();

            // Only disable orbit controls if a control is actually active
            controls.enabled = !isAnyControlActive();
            
            // Update button glows
            glows.A.material.opacity = inputManager.isButtonPressed(StandardMapping.buttons.A) ? 0.5 : 0;
            glows.B.material.opacity = inputManager.isButtonPressed(StandardMapping.buttons.B) ? 0.5 : 0;
            glows.X.material.opacity = inputManager.isButtonPressed(StandardMapping.buttons.X) ? 0.5 : 0;
            glows.Y.material.opacity = inputManager.isButtonPressed(StandardMapping.buttons.Y) ? 0.5 : 0;

            handleJoystickInputs(deltaTime);
            fireballUpdates(deltaTime);
            
            // Render both scenes
            renderer.clear();
            renderer.render(scene, camera); 
            renderer.clearDepth(); 
            renderer.render(uiScene, uiCamera); // UI on top
            
            const stick = inputManager.getStick('LEFT');
            /**
             * Note: Physical controllers may have slightly different gate shapes.
             * For consistent behavior across all input types, consider normalizing
             * stick magnitude to 1.0 in your game code.
             */
            const joystickMagnitude = Math.sqrt(stick.x * stick.x + stick.y * stick.y);

            output.innerHTML = `
                <table>
                <tr>
                    <td>Joystick:</td>
                    <td class="${Math.abs(stick.x) > 0.1 ? 'active' : ''}">X: ${stick.x.toFixed(2)}</td>
                    <td class="${Math.abs(stick.y) > 0.1 ? 'active' : ''}">Y: ${stick.y.toFixed(2)}</td>
                    <td class="${joystickMagnitude > 0.1 ? 'active' : ''}">Magnitude: ${(joystickMagnitude * 100).toFixed(0)}%</td>
                    <td>Touches: ${touchInput.activeTouches.size}</td>
                </tr>
                <tr>
                    <td>Buttons:</td>
                    <td class="${inputManager.isButtonPressed(StandardMapping.buttons.A) ? 'pressed' : ''}">A: ${inputManager.isButtonPressed(StandardMapping.buttons.A) ? '✅' : '❌'}</td>
                    <td class="${inputManager.isButtonPressed(StandardMapping.buttons.B) ? 'pressed' : ''}">B: ${inputManager.isButtonPressed(StandardMapping.buttons.B) ? '✅' : '❌'}</td>
                    <td class="${inputManager.isButtonPressed(StandardMapping.buttons.X) ? 'pressed' : ''}">X: ${inputManager.isButtonPressed(StandardMapping.buttons.X) ? '✅' : '❌'}</td>
                    <td class="${inputManager.isButtonPressed(StandardMapping.buttons.Y) ? 'pressed' : ''}">Y: ${inputManager.isButtonPressed(StandardMapping.buttons.Y) ? '✅' : '❌'}</td>
                </tr>
                <tr>
                    <td>Camera:</td>
                    <td colspan="4">Orbit Controls ${controls.enabled ? 'Enabled' : 'Disabled'}</td>
                </tr>
                </table>`;
        }
        
        resize();
        window.addEventListener('resize', resize);
        animate();
    </script>
</body>
</html>